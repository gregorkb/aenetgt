# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

EYgibbs <- function(N, p, Y, Z, se, sp, na, GI) {
    .Call(`_aenetgt_EYgibbs`, N, p, Y, Z, se, sp, na, GI)
}

EYiYjgibbs_slow <- function(N, p, Y, Z, se, sp, na, GI) {
    .Call(`_aenetgt_EYiYjgibbs_slow`, N, p, Y, Z, se, sp, na, GI)
}

CovYiYjgibbs <- function(N, p, Y, Z, W, se, sp, EY, na, GI) {
    .Call(`_aenetgt_CovYiYjgibbs`, N, p, Y, Z, W, se, sp, EY, na, GI)
}

#' Compute the elastic net estimator for logistic regression
#' 
#' @param Yr Response vector of 1s and 0s
#' @param Xr A design matrix with the first column a column of 1s
#' @param lambda The tuning parameter governing the strength of the elastic net penalty
#' @param gammar A vector of length \code{ncol(X) - 1} giving the weights applied to each covariate in the elastic net penalization
#' @param theta Value controlling the relative strength of the ridge and lasso penalties; 1 gives lasso.
#' @param tol Convergence tolerance
#' @return a list with the estimated coefficients, etc.
#' 
#' @examples
#' # generate some data
#' n <- 5000
#' p <- 40
#' b <- c(0,3,0,1,-2,0,rep(0,p-5)) # first is intercept
#' X <- cbind(rep(1,n),scale(matrix(rnorm(n*p),nrow=n),TRUE,TRUE))
#' eta <- X %*% b
#' Y <- rbinom(n,1,1/(1 + exp(-eta)))
#' 
#' # compute elastic net estimator  
#' logistic_enet(Y, X, lambda = 30, gammar = rep(1,p), theta = 0.5, tol = 0.0001)$b
logistic_enet <- function(Yr, Xr, lambda, gammar, theta, tol) {
    .Call(`_aenetgt_logistic_enet`, Yr, Xr, lambda, gammar, theta, tol)
}

llj_array <- function(Zjr, Zjc, Yji, whichjretest, pxji, Se, Sp, B) {
    .Call(`_aenetgt_llj_array`, Zjr, Zjc, Yji, whichjretest, pxji, Se, Sp, B)
}

#' Generate all possible sequences of 0s and 1s of a given length
#' @param a the length of the sequences.
#' @return a matrix containing in its rows the sequences of 0s and 1s.
all_binary_sequences <- function(a) {
    .Call(`_aenetgt_all_binary_sequences`, a)
}

#' Computes conditional expectations of individual disease statuses for individual, master pool, or Dorfman testing
#'   
#' @param Z Group testing output from one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}.
#' @param Y Group testing output from one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}.
#' @param eta the value of the linear predictor
#' @param Se A vector of testing sensitivities of length \code{max(Z[,3])}.
#' @param Sp A vector of testing specificities of length \code{max(Z[,3])}.
#' @return The vector of conditional expectations.
#' 
#' This function computes the conditional expectations of each individual disease status given the observed assay data.
#' 
#' @examples
#' # generate individual covariate values and disease statuses
#' N <- 100
#' data <- model1(N)
#' X <- data$X
#' Y.true <- data$Yi
#' Se <- c(.95,.92) # set master pool and individual assay sensitivity
#' Sp <- c(.97,.98) # set master pool and individual assay specificity
#' cj <- 4 # set size of master pools
#' # subject individuals to Dorfman testing
#' assay.data <- dorfman.assay.gen(Y.true,Se,Sp,cj)
#' Z <- assay.data$Z
#' Y <- assay.data$Y
#' b <- data$b
#' eta <- X %*% b
#' EY <- EYexact(Z,Y,eta,Se,Sp)
EYexact <- function(Z, Y, eta, Se, Sp) {
    .Call(`_aenetgt_EYexact`, Z, Y, eta, Se, Sp)
}

